# 第三章-数据和C

## 3.1 示例程序

```c
#include <stdio.h>

int main(void)
{
	float weight;
	float value;

	printf("Are you worth your weight in platinum?\n");
	printf("Let's check it out.\n");
	printf("Please enter your weight in pounds:");

	scanf("%f1", &weight);

	value = 1700.0 * weight * 14.5833;
	printf("Your weight in platinum is worth $%.2f.\n", value);
	printf("Your are easily worth that! IF platinum prices drop,\n");
	printf("eat more to maintain your value. \n");



	return 0;
}
```

### 3.1.1 程序中的新元素

浮点数类型（float）的变量，可以存储带小数的数字。

printf()中 使用%f来处理浮点值。%.2f中的.2用于精确控制输出，指定输出的浮点数指显示小数点后面两位。

## 3.2 变量与常量数据

​	有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为**常量**。

其他数据理性在程序运行期间可能会改变或被赋值，这些称为**变量**。

## 3.3 数据：数据类型关键字

计算机的储存可分为两大基本来兴：整数累心和浮点数类型。

**位、字节和字**

> 最小的存储单元是位(bit)，可以储存0或1。位是计算机内存的基本构件块。
>
> 字节(byte) 是常见的计算机存储单位。1字节均为8位。8位字节就有256中可能。
>
> 字(word) 是设计计算机时给定的自然存储单位。

### 3.3.1 整数和浮点数

### 3.2.2 整数

在C语言中，整数是没有小数部分的数。

### 3.3.3 浮点数

2.75、3.16E7、7.00和2e-8都是浮点数。

3.16E7表示3.16* 10^7，7被称为10的指数。

![image-20250712103111332](第三章-数据和C.assets/image-20250712103111332.png)

- 整数没有小数部分，浮点数有小数部分。
- 浮点数可以表示得到范围比整数大。
- 对于一些算术运算（如：两个很大的数相减），浮点数损失的精度更多。
- 因为在任何区间内都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值。浮点数通常只是实际值的近似值。
- 过去，浮点运算比整数运算慢。现在缩小了速度上的差距。

## 3.4 C语言基本数据类型

### 3.4.1 int类型

​	int类型是有符号整型，即int类型的值必须是整数，可以是正整数、负整数或零。取值范围依计算机系统而异。

#### 1. 声明int变量

```c
int erns; // 单独声明
int hosg, cows,goats; // 变量名之间用逗号间隔
```



#### 2. 初始化变量

初始化(initialise)变量就是为变量赋一个初始值。在C语言中，初始化可以直接在声明中完成。

```c
int hosg =21;
int cow = 32,goasts = 14;
int dogs,cars = 96; // 这里只初始化了cars，dogs并未初始化
```

#### 3. int 类型常量

​	上面中出的整数（21，32，14和94）都是整形常量或整形字面量。C语言把不含小数点和指数的数作为整数。

#### 4. 打印 int 值

要确保转换说明的数量与待打印值的**数量相同**，编译器**不会**捕获这类型的错误。

![image-20250713145736822](%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%92%8CC.assets/image-20250713145736822.png)

> 编译的时候未出现错误
>
> 执行的时候才会报错

​	大部分函数都需要指定数目的参数，编译器会检查参数的数目是否正确。但是，**printf() 函数的参数数目不定**，可能有1个、2个、3个或更多，编译器也爱莫能助。

5. 八进制和十六进制

**0x**或0X前缀	表示**十六进制值**

**0**前缀	表示**八进制**

6.  显示八进制和十六进制

- 十进制显示数字，使用 `%d`
- 八进制显示数字，使用`%o`
- 十六进制显示数字，用`%x`
- 显示数字前缀在加`#`即 `%#d`，`%#o`，`%#x`

### 3.4.2 其他整数类型

在任何有符号类型前面添加关键字 `signed`，可强调使用**有符号类型**的意图。

#### 1. 声明其他整数类型

#### 2.使用多种整数类型的原因

​	C语言只规定了short占用的存储空间不能多与int，long占用的存储空间不能少于int。这样规定是为了适应不同的机器。

​	如果一个数值超出了 `int` 类型的取值范围（例如，大于 `INT_MAX` 或小于 `INT_MIN`），但在 `long` 类型的取值范围内，那么**必须**使用 `long` 类型来存储该数值，否则会导致**数据溢出**或**错误**。

​	在某些系统中，`long` 类型占用的存储空间比 `int` 更大（例如，`int` 是 32 位，`long` 是 64 位）。这种情况下，使用 `long` 类型**可能会降低运算速度**。

​	如果在long类型和int类型占用空间相同的机器上编写代码，当确实需要32位的整数时，应使用long类型而不是int类型，以便把程序移植到16位后仍然可以正常工作。类似地，如果确实需要64位的整数，应使用long long类型。

#### 3. long变量 和long long 变量

​	通常，程序代码中使用的数字都被储存位int类型。如果使用1000000这类的大数字，超出了int类型能表示的范围，编译器会将其视为long int类型。如果数字超出long 可表示的最大值，编译器则将其视为unsigned long 类型。如果还不够大，编译器则将其视为 longlong或 unsigned long long类型。

`int` = > `long` => `unsigend long` => `long long \ unsigned long`

八进制和十六进制也一样，通常被视为int类型，如果不够大，会按照上面依次使用。

特殊情况（编译器以long类型存储一个小数字）

- 编程时要显式使用IBM PC上的内存地址时。
- 一些C标准函数也要求使用long类型的值。要把一个较小的常量作为long类型对待，可以在值的末尾加上l(小写的L)或L后缀。L后缀也可以用于八进制和十六进制整数。（早期编译器用段寄存器16为+偏移量16位，实际物理地址时20位；避免隐式类型转换的风险；标准库和硬件规范的要求）

类似的，在支持long long 类型的系统中，也可以使用ll或者 LL 后缀表示 longlong类型的值，如3LL。另外，u或U后缀表示 unsigned long long，如 5ull、10LLU、6LLU 或 9ULL。

**AI搜索**

| 后缀组合           | 类型（C/C++）                       | 示例    |
| :----------------- | :---------------------------------- | :------ |
| **`u` 或 `U`**     | `unsigned int`                      | `42U`   |
| **`l` 或 `L`**     | `long`                              | `42L`   |
| **`ul` 或 `UL`**   | `unsigned long`                     | `42UL`  |
| **`ll` 或 `LL`**   | `long long` (C99/C++11 起)          | `42LL`  |
| **`ull` 或 `ULL`** | `unsigned long long` (C99/C++11 起) | `42ULL` |

​	对于short类型，可以使用h前缀。`%hd`表示以十进制显示short类型的整数，`%ho`表示以半只显示short类型的整数。h和l前缀都可以和u一起使用。

### 3.4.3 使用字符：char类型

#### 1. 声明char类型变量

#### 2. 字符常量和初始化

​	char 类型用于 存储字符，但是从技术层面看，char是整数类型。因为char类型实际存上储存的是整数而不是字符。计算机使用数字编码来处理字符，即用特定的整数表示特定的字符。美国最常用的编码是ASCII编码。

​	标准ASCII码的范围是0~127，只需要7位二进制数表示。用的统一码（Unicode)商用的统一码(Unicode)创建了一个能表示世界范围内多种字符集的系统，目前包含的字符已超过110000个。国际标准化组织（ISO）和国际电工技术委员会（IEC）为字符集开发了ISO/IEC10646标准。统一码标准也与ISO/IEC10646标准兼容。

​	在C语言中，用单引号括起来的单个字符被称为**字符常量**。编译器发现'A'，就会将其转化为相应的代码值。

```c
char grade = 65; // 这样赋值是没问题的，但不建议
```

​	利用字符常量的这种特性，可以定义一个字符常量`FATE`,即把4个独立的8位ASCII码储存在一个32位存储单元中。如果把这样的字符常量赋给char类型变量grade，只有最后8位有效。因此，grade的值是`E`。

![image-20250713165606371](%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%92%8CC.assets/image-20250713165606371.png)

#### 3. 非打印字符

有些ASCII字符打印不出来。例如，一些代表行为的字符。C语言提供3种方法表示这些字符。

1. ```c
   char beep = 7;
   ```

2. 使用特殊的符号序列表示一些特殊的字符。这些符号序列叫**转义字符**。
   把转义字符赋给字符变量是，必须要哪个单引号把转义字符括起来。

   ```c
   char nerf = '\n';
   ```

   ​	C标准规定**警报字符不得改变活跃位置**。标准中的**活跃位置**指的是**显示设备**（屏幕、电传打字机、打印机等）中下一个字符将出现的位置。简而言之，平时常说的屏幕光标位置就是活跃位置。在程序中把警报字符输出在屏幕上的效果是，发出蜂鸣，但不会移动屏幕光标。
   ​	`\0oo``与\xhh`是ASCII码的特殊表示。如果要用八进制ASCII码表示一个字符。可以在编码值前加一个反斜杠`\`并用单引号括起来。

3. ​	用十六进制表示字符常量，即反斜杠后面跟一个 **x** 或 **X**，再加上**1~3位**十六进制数字。例如，CTRL + P字符的ASCII十六进制码是（相遇于是十进制的16），可以表示位 `\x10` 或 `\x010` 。

- 无论是普通字符还是转义序列，只要是双引号括起来的字符集合，就无需用单引号括起来。

#### 4. 打印字符

`printf ()` 函数中的转换说明决定了数据的**显示方式**，而不是数据的**储存方式**。

#### 5. 有符号还是无符号

​	有些C编译器把char实现为有符号类型，意味着char可表示范围是-128 ~ 127。而有些C编译器把char实现为无符号类型，那么char可表示的范围是0 ~ 255。

------

### 3.4.4 _Bool类型

​	C99 标准添加了 `_Bool` 类型，用于表示布尔值，即逻辑值 true 和 false。因为C语言用值1表示true，值0表示false。所以`_Bool` 类型实际上也是一种**整数类型**。但原则上他仅**占用1个存储空间**，因为对0 和 1 而言，1位的存储空间足够了。

**AI解释**

- **最少占用1字节**：虽然 `_Bool` 理论上只需要1个比特（bit）即可存储（0或1），但C标准规定**最小的可寻址单位是字节**（通常1字节=8比特）。因此，`_Bool` 实际会占用至少1字节的存储空间。
- **编译器优化**：某些编译器可能在结构体或位域（bit-field）中优化 `_Bool` 的存储，例如将**多个 `_Bool` 成员打包到同一个字节的不同比特位**（需显式使用位域语法）。但单独定义的 `_Bool` 变量仍会占用完整的1字节。

![image-20250714091201060](第三章-数据和C.assets/image-20250714091201060.png)

> 注意：要在release模式下才生效。

------

### 3.4.5 可移植类型： stdint.h 和 inttypes.h 

C99 新增两个头文件 stdint.h 和 inttypes.h。

​	C语言为现有类型创建了更多类型名。这些新的类型名定义在 stdint.h 头文件中。例如，`int32_t` 表示32 位的有符号整数类型。在使用32位int的系统中，头文件会把 `int32_t` 作为 `int`的别名。**不同的系统也可以定义相同的类型名**（不受编译器和平台的影响）。例如，`int` 为 16位、`long` 为32位的系统会把 `int32_t` 作为`long` 的别名。

![image-20250714091829980](第三章-数据和C.assets/image-20250714091829980.png)

​	上面讨论的类型别名是**精确宽度整数类型**。int32_t表示整数类型的宽度正好是32位。但是。**计算机的底层系统可能不支持**。因此，精确宽度整数类型是**可选项**。



​	C99和C11提供了第2类别名集合。一些类型名保证所表示的类型一定是**至少有指定宽度的最小整数类型**。这组类型集合被称为**最小宽度类型**。例如，`int_least8_t`是可容纳8位有符号整数值的类型中宽度最小的类型的一个别名。如果某系统的最小整数类型是16位，可能不会定义 `int8_t` 类型。尽管如此，该系统仍可使用 `int_least8_t` 类型，但可能把该类型实现为16位的整数类型。（简单来说，int8_t是精确型，规定多少是多少；而int_least8_t 是至少型，只能比它大或相等，不能比它小。）



​	C99和C11定义了一组**可使计算达到最快的类型集合**。这组类型集合被称为**最快最小宽度类型**。例如， `int_fast8_t` 被定义为系统中对**8位有符号值而言运算最快的整数类型**的别名。



​	C99定义了**最大的有符号整形类型** `intmax_t` ，可存储任何有效的有符号整数值。类似的， `	` 表示**最大的无符号整数类型**。

> 解释：
>
> 





























